package ProjectModel;
import java.util.ArrayList;
import java.util.Set;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;


@Entity(name = "STUDENTS")
public class Student {
    
    //Primary Key
    
    // Int Justification:
    // int should be enough for student ID's
    // in CSULB student ID's are currently 9 digits long (999,999,999 max)
    // Since max int is around 2bil, we should be fine representing them this way
    
    // Not an autogenerated value since students have an actual campus ID - @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Id
    @Column(name = "STUDENT_ID")
    private int studentID;
    
    //Attributes needed
    @NotNull
    @Column(length = 128)
    private String name;

    @ManyToMany(mappedBy = "students")
    private Set<Section> sections;


    @OneToMany(mappedBy = "student")
    private Set<Transcript> transcripts;

    //Bi-Directional adder
    public void addSection(Section s) { 
        this.pushSection(s); 
        s.pushStudent(this); 
    }

    // Helper for addSection
    public void pushSection(Section s){
        this.sections.add(s);
    }

    // Logic Methods
    /**
     * Calculates a student's GPA using it's transcripts
     * @return double representation of student GPA
     */
    public double getGPA(){
          
        double totalPoints = 0;
        double totalUnits = 0;
        

        for(Transcript t: transcripts){
       

            if(t.getStudent() == this){

                
                double units = t.getSection().getCourse().getUnits();
                double gradePoints;

                if(t.getGradeEarned() == "A"){
                    gradePoints = 4;
                } 
                else if (t.getGradeEarned() == "B"){
                    gradePoints = 3;
                }
                else if (t.getGradeEarned() == "C"){
                    gradePoints = 2;
                }
                else if (t.getGradeEarned() == "D"){
                    gradePoints = 1;
                }
                else{gradePoints = 0;}

                totalPoints = totalPoints + (gradePoints * units);
                totalUnits = totalUnits + units;

            }

            
        }
        double GPA = totalPoints/totalUnits;

        return GPA; 
    }

    public enum RegistrationResult { SUCCESS, ALREADY_PASSED, ENROLLED_IN_SECTION, NO_PREREQUISITES, ENROLLED_IN_ANOTHER, TIME_CONFLICT };
    /**
     * Attempts
     * @param s
     * @return
     */
    public RegistrationResult registerForSection(Section s){

        // The student is already enrolled in the section or different section of that course
        for(Section sec: sections){
            if(sec == s)
                return RegistrationResult.ENROLLED_IN_SECTION;
            else if(sec.getCourse() == s.getCourse())
                return RegistrationResult.ENROLLED_IN_ANOTHER;

            // No issues with section itself, checking time conflicts
            TimeSlot oldSlot = sec.getTimeslot();
            TimeSlot newSlot = s.getTimeslot();
            
            // Will have some numeric value if there are conflicts
            byte sameDays = (byte) (oldSlot.getDaysOfWeek() & newSlot.getDaysOfWeek());
            if(sameDays != 0){
                if(!oldSlot.getStartTime().isAfter(newSlot.getEndTime()) && !newSlot.getStartTime().isAfter(oldSlot.getEndTime())){
                    return RegistrationResult.TIME_CONFLICT;
                }
            }

        }        
        
        // The student has already received a "C" or better in the course.
        for(Transcript t: transcripts){
            if(t.getSection().getCourse() == s.getCourse()){
                String grade = t.getGradeEarned();
                if(grade == "C" || grade == "B" || grade == "C"){
                    return RegistrationResult.ALREADY_PASSED;
                }
            }
        }

        // The student has not met the course prerequisites.
        for(Prerequisite pr: s.getCourse().getPrerequisites()){
            boolean passedPre = false;
            for(Transcript t: transcripts){
                if(pr.getPrereqCourse() == t.getSection().getCourse()){
                    if(Character.toString(pr.getMinimumGrade()) == t.getGradeEarned()){
                        passedPre = true;
                        break;
                    }
                }
            }
            if(!passedPre)
                return RegistrationResult.NO_PREREQUISITES;
        }
        
        addSection(s);
        return RegistrationResult.SUCCESS;
    }

    // Constructor & Accessor / Mutators below
    public Student() {
    }

    public Student(int studentID, String name) {
        this.studentID = studentID;
        this.name = name;
    }

    public Set<Transcript> getTranscripts(){
        return transcripts;
    }

    public int getStudentID() {
        return this.studentID;
    }

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Set<Section> getSections() {
        return sections;
    }

    public void setSections(Set<Section> sections) {
        this.sections = sections;
    }

    @Override
    public String toString() {
        return getName() + ", ID: "
            + getStudentID();
    }


}
